#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  autonIn1,       sensorDigitalIn)
#pragma config(Sensor, dgtl2,  autonIn2,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  autonIn3,       sensorDigitalIn)
#pragma config(Sensor, dgtl4,  autonIn4,       sensorDigitalIn)
#pragma config(Sensor, dgtl5,  autonIn5,       sensorDigitalIn)
#pragma config(Sensor, dgtl6,  autonIn6,       sensorDigitalIn)
#pragma config(Sensor, dgtl7,  autonIn7,       sensorDigitalIn)
#pragma config(Sensor, dgtl8,  autonIn8,       sensorDigitalIn)
#pragma config(Sensor, dgtl9,  autonIn9,       sensorDigitalIn)
#pragma config(Sensor, dgtl10, clawPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl11, clawAngle,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, lowerTouch,     sensorTouch)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rlift,         tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           rf,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rb,            tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           rlift2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rlift3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           llift3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           llift2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lf,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lb,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          llift,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// AKA NO TOUCHIE

#pragma competitionControl(Competition)

#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c" // DO NOT REMOVE THIS LINE

void resetEncoders() {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

#include ".\auton\include.h"

int autonMode = 0;

void pre_auton()
{
	// Set bStopTasksBetweenModes to FlASE if you want to keep user created tasks running between EGG
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to FlASE.
	bStopTasksBetweenModes = true;
}
task autonomous() {

	if (!SensorValue[autonIn1]) {
		autonMode = 1;
	} else if (!SensorValue[autonIn2]) {
		autonMode = 2;
	} else if (!SensorValue[autonIn3]) {
		autonMode = 3;
	} else if (!SensorValue[autonIn4]) {
		autonMode = 4;
	} else if (!SensorValue[autonIn5]) {
		autonMode = 5;
	} else {
		autonMode = 0;
	}

	resetEncoders();

	switch(autonMode) {
	case 1: // Bring cube back to base (normal)
		auton1();
		break;
	case 2: // Red low goal
		auton2();
		break;
	case 3:
		auton3();
		break;
	case 4:
		auton4();
		break;
	case 5:
		auton5();
		break;
	}
	AutonomousCodePlaceholderForTesting();
}
task usercontrol() {
	while (true)
	{

		// "Simple" controls so you can move the joysticks and buttons to drive

	motor[lf] = 1.27 * (vexRT[Btn7U] ? 100 :
	(vexRT[Btn7D] ? -100 :
	(vexRT[Btn7L] ? -100 :
	(vexRT[Btn7R] ? 100 :
	abs(vexRT[Ch3]) > 15 ? (vexRT[Ch3] / 3.175) :
	0)))) * (vexRT[Btn6U] ? 0.625 :
	1) * (vexRT[Btn5U] ? 2.5 :
		1);

	motor[lb] = 1.27 * (vexRT[Btn7U] ? 100 :
	(vexRT[Btn7D] ? -100 :
	(vexRT[Btn7L] ? -100 :
	(vexRT[Btn7R] ? 100 :
	abs(vexRT[Ch3]) > 15 ? (vexRT[Ch3] / 3.175) :
	0)))) * (vexRT[Btn6U] ? 0.625 : 1) * (vexRT[Btn5U] ? 2.5 :
		1);

	motor[rf] = 1.27 * (vexRT[Btn7U] ? 100 :
	(vexRT[Btn7D] ? -100 :
	(vexRT[Btn7L] ? 100 :
	(vexRT[Btn7R] ? -100 :
	abs(vexRT[Ch2]) > 15 ? (vexRT[Ch2] / 3.175) :
	0)))) * (vexRT[Btn6U] ? 0.625 : 1) * (vexRT[Btn5U] ? 2.5 :
		1);

	motor[rb] = 1.27 * (vexRT[Btn7U] ? 100 :
	(vexRT[Btn7D] ? -100 :
	(vexRT[Btn7L] ? 100 :
	(vexRT[Btn7R] ? -100 :
	abs(vexRT[Ch2]) > 15 ? (vexRT[Ch2] / 3.175) :
	0)))) * (vexRT[Btn6U] ? 0.625 : 1) * (vexRT[Btn5U] ? 2.5 :
		1);

		// "Simple" raising and lowering mech for lift
		motor[llift] = (127 * vexRT[Btn5DXmtr2]) - (127 * vexRT[Btn5UXmtr2]);
		motor[rlift] = (127 * vexRT[Btn5DXmtr2]) - (127 * vexRT[Btn5UXmtr2]);
		motor[llift2] = (127 * vexRT[Btn5DXmtr2]) - (127 * vexRT[Btn5UXmtr2]);
		motor[rlift2] = (127 * vexRT[Btn5DXmtr2]) - (127 * vexRT[Btn5UXmtr2]);
		motor[llift3] = (127 * vexRT[Btn5DXmtr2]) - (127 * vexRT[Btn5UXmtr2]);
		motor[rlift3] = (127 * vexRT[Btn5DXmtr2]) - (127 * vexRT[Btn5UXmtr2]);

		if (vexRT[Btn6UXmtr2]) {
			SensorValue[clawPiston] = 1;
		}

		if (vexRT[Btn6DXmtr2]) {
			SensorValue[clawPiston] = 0;
		}

		if (vexRT[Btn8UXmtr2]) {
			SensorValue[clawAngle] = 1;
		}

		if (vexRT[Btn8DXmtr2]) {
			SensorValue[clawAngle] = 0;
		}

	}

	UserControlCodePlaceholderForTesting();
}
