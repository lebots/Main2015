#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  autonIn1,       sensorDigitalIn)
#pragma config(Sensor, dgtl2,  autonIn2,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  autonIn3,       sensorDigitalIn)
#pragma config(Sensor, dgtl4,  autonIn4,       sensorDigitalIn)
#pragma config(Sensor, dgtl5,  autonIn5,       sensorDigitalIn)
#pragma config(Sensor, dgtl6,  autonIn6,       sensorDigitalIn)
#pragma config(Sensor, dgtl7,  autonIn7,       sensorDigitalIn)
#pragma config(Sensor, dgtl8,  autonIn8,       sensorDigitalIn)
#pragma config(Sensor, dgtl9,  autonIn9,       sensorDigitalIn)
#pragma config(Sensor, dgtl10, clawPiston,     sensorDigitalOut)
#pragma config(Sensor, dgtl11, clawAngle,      sensorDigitalOut)
#pragma config(Sensor, dgtl12, lowerTouch,     sensorTouch)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rlift,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rf,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rb,            tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           rlift2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rlift3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           llift3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           llift2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lf,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           lb,            tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          llift,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// AKA NO TOUCHIE

#pragma competitionControl(Competition)

#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c" // DO NOT REMOVE THIS LINE

void resetEncoders() {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void lift(int power) {
	motor[llift] = power;
	motor[rlift] = power;
	motor[llift2] = power; // Sets lift power, so you have much less
	motor[rlift2] = power; // typing every time you set the lift.
	motor[llift3] = power;
	motor[rlift3] = power;
}

#include ".\auton\include.h" // Includes all autonomous files

// Instantiate local variables
int lp = 0;
int rp = 0;
short mainBattery = nImmediateBatteryLevel;
short backupBattery = BackupBatteryLevel;

void pre_auton()
{
	bStopTasksBetweenModes = true;
}
task autonomous() {

	resetEncoders(); // Resets encoders

	if (!SensorValue[autonIn1]) {
		auton1(); // Red low goal
	} else if (!SensorValue[autonIn2]) {
		auton2(); // Blue low goal
	} else if (!SensorValue[autonIn3]) {
		auton3(); // Forward grab cube back up
	} else if (!SensorValue[autonIn4]) {
		auton4(); // 180 to the right
	} else if (!SensorValue[autonIn5]) {
		auton5(); // 180 to the left
	} else if (!SensorValue[autonIn6]) {
		auton6(); // Blue skyrise
	} else if (!SensorValue[autonIn7]) {
		auton7(); // Red skyrise
	}
}
task usercontrol() {
	while (true)
	{
		// Button controls for driving
		lp = (vexRT[Btn7U] ? 100 : (vexRT[Btn7D] ? -100 : (vexRT[Btn7L] ? -100 : (vexRT[Btn7R] ? 100 : 0))));
		rp = (vexRT[Btn7U] ? 100 : (vexRT[Btn7D] ? -100 : (vexRT[Btn7L] ? 100 : (vexRT[Btn7R] ? -100 : 0))));
		// the vexRT[Btn] ? 100 : () means if the button is pressed, the 100 will go, if not, the () will go

		// Controls for joysticks
		lp += (abs(vexRT[Ch3]) > 15 ? (vexRT[Ch3] / 3.175) : 0);
		rp += (abs(vexRT[Ch2]) > 15 ? (vexRT[Ch2] / 3.175) : 0);

		// Slow and Fast drive button
		lp *= (vexRT[Btn6U] ? 0.75 : 1) * (vexRT[Btn5U] ? 2.5 : 1);
		rp *= (vexRT[Btn6U] ? 0.75 : 1) * (vexRT[Btn5U] ? 2.5 : 1);

		// Set motor powers
		motor[lf] = 1.27 * lp;
		motor[lb] = 1.27 * lp;
		motor[rf] = 1.27 * rp;
		motor[rb] = 1.27 * rp;

		// Raise and lower lift
		lift((-127 * vexRT[Btn5DXmtr2]) + (127 * vexRT[Btn5UXmtr2]));

		// Close claw
		if (vexRT[Btn6UXmtr2]) SensorValue[clawPiston] = 1;

		// Open claw
		if (vexRT[Btn6DXmtr2]) SensorValue[clawPiston] = 0;

		// Tilt claw up
		if (vexRT[Btn8UXmtr2]) SensorValue[clawAngle] = 1;

		// Tilt claw down
		if (vexRT[Btn8DXmtr2]) SensorValue[clawAngle] = 0;

		// Display voltages to local variables
		mainBattery = nImmediateBatteryLevel;
		backupBattery = BackupBatteryLevel;
	}
}
